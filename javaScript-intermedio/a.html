<!-- 2 static: atributos y métodos estáticos en jS

podemos saltarnos la creación de una instancia de un prototipo para acceder a sus atributos.
para eso tenemos "static" como palabra reservada,
por ejemplo:

-----------------------------------------------------------------

class Patito {
    static sonidito = "cuak!";
}
console.log(Patito.sonidito);
// cuak!

-----------------------------------------------------------------
esto tambien funciona con los metodos por ejemplo:

class Patito {
    static hacerSonido() {
        return "cuak!";
    }
}
console.log(Patito.hacerSonido());
// cuak!

recordar que la palabra reserbada static al principio del metodo es para acceder al metodo sin la necesidad de crear una instancia.

-----------------------------------------------------------------
esto es interesante para lo que podriamos usalo pero echemos un visatzo a el prototipo object y sus comportamientos.
si tenemos un objeto x y le aplicamos Object.keys(x):
nos devolverá todos los nombres clave de nuestro objeto x.

const objetito = {
    name: "Marcus",
    email: "andresmarcorossel@gmail.com",
    age: 29
};

Object.keys(objetito);
// ["name", "email", "age"]

-----------------------------------------------------------------
lo mismo pasa con el metodo estatico getOwnPropertyNames, luego veremos las pequeñas diferencias entre estas dos:

const objetito = {
    name: "Marcus",
    email: "andresmarcorossel@gmail.com",
    age: 29
};

Object.getOwnPropertyNames(objetito);
// ["name", "email", "age"]

-----------------------------------------------------------------
tambien tenemos otros metodos estaticos como Object.entries();
esto nos devolvera un array de arrays.

const objetito = {
    name: "Marcus",
    email: "andresmarcorossel@gmail.com",
    age: 29
};

Object.entries(objetito);
// [
    0: ["name", "Marcus"]
    1: ["email", "andresmarcorossel@gmail.com"]
    2: ["age", 29]
]

-----------------------------------------------------------------
tenemos otro metodo estatico muy importante que es
Object.getOwnPropertyDescriptors(objetito);
nos va a devolver todas las propiedades de nuestro objeto como un objeto pero con el nombre de nuestra propiedad pero despues tenemos otros atributos 

//name: {
    value: "Marcus",
    writable: true,
    configurable: true,
    enumerable: true
}

que significan estas claves, de donde salieron?
son para configurar quien puede axeder, modificar, limitar, jugar nuestros objetos.
esto es muy poderoso.

-->
<!-- 3 métodos estáticos del prototipo object

resumen de los metodos prototipos
------------------------------------------------------------
Object.keys(marco);
    genera en consola los nombres clave en formato lista.

------------------------------------------------------------
Object.getOwnPropertyNames(marco);
    lo mismo que keys pero con lebes diferencias que se veran
    más adelante

------------------------------------------------------------
Object.entries(marco);
    nos permite ver más en profundidad las propiedades de nuestro
    prototipo para chequear los niveles de permiso que traen 
    por defecto.

-->
<!-- 4 Object.defineProperty

al crear las pruebas de Object.defineProperty() jugamos con los valores por defecto para saber que pasa en el navegador y sus diferencias.

Object.defineProperty(marco, "navegator", {
  value: "Chrome",
  enumerable: false,
  writable: true,
  configurable: true
});

cuando enumerable es false, en consola "chrom dev" usamod Object.keys(marco), nos sale el listado de claves pero no aparese navegator.
pero si usamos Object.getOwnPropertyNames(marco), aparecen todos los nombres clave, "esta es la diferencia entre keys y getOwnPropertyNames"

----------------------------------------------------------------------
si aplicamos marco.navigator = "textoDePrueba"
se guarda y por lo tanto se puede seguir ocupando.
tambien podemos eliminarla:     delete marco.navigator
nos mustra un true, por lo que se elimino.

----------------------------------------------------------------------
----------------------------------------------------------------------
Object.defineProperty(marco, "editor", {
  value: "VSCode",
  enumerable: true,
  writable: false,
  configurable: true
});

cuando cambiamos el writable a false pasa lo siguiente.
si aplico Object.keys(marco)  | nos imprime en consola: si aparece en la lista de nombres clave, por que ya tiene el enumerable: true.

si aplicamos marco.editor = "loQueSea", nos dejara pero no lo aplicara
por que con writable: false no nos deja editar.

si aplicamos delete marco.editor | nos sale true, por lo que si se puede eliminar.
------------------------------------------------------------------------------------------------------------------------------------------------
Object.defineProperty(marco, "terminal", {
  value: "WSL",
  enumerable: true,
  writable: true,
  configurable: false
});

si aplicamos configurable: false. 
si usamos Object.keys and Object.getOwnPropertyNames nos sigue mostrando
terminal en la lista de nombres clave.

si aplico marco.terminal = "cmder". si nos deja
pero si aplicamos delete marco.terminal no nos deja.

------------------------------------------------------------------------------------------------------------------------------------------------
Object.defineProperty(marco, "pruebaNASA", {
  value: "extraterrestres",
  enumerable: false,
  writable: false,
  configurable: false
});

con prueba de la nasa no se ve con .keys 
pero con getOwnPropertyNames si nos aparece
no nos deja eliminarla ni editar el valor

-->
<!--  -->
<!--  -->
<!--  -->