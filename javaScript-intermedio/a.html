<!-- 2 static: atributos y métodos estáticos en jS

podemos saltarnos la creación de una instancia de un prototipo para acceder a sus atributos.
para eso tenemos "static" como palabra reservada,
por ejemplo:

-----------------------------------------------------------------

class Patito {
    static sonidito = "cuak!";
}
console.log(Patito.sonidito);
// cuak!

-----------------------------------------------------------------
esto tambien funciona con los metodos por ejemplo:

class Patito {
    static hacerSonido() {
        return "cuak!";
    }
}
console.log(Patito.hacerSonido());
// cuak!

recordar que la palabra reserbada static al principio del metodo es para acceder al metodo sin la necesidad de crear una instancia.

-----------------------------------------------------------------
esto es interesante para lo que podriamos usalo pero echemos un visatzo a el prototipo object y sus comportamientos.
si tenemos un objeto x y le aplicamos Object.keys(x):
nos devolverá todos los nombres clave de nuestro objeto x.

const objetito = {
    name: "Marcus",
    email: "andresmarcorossel@gmail.com",
    age: 29
};

Object.keys(objetito);
// ["name", "email", "age"]

-----------------------------------------------------------------
lo mismo pasa con el metodo estatico getOwnPropertyNames, luego veremos las pequeñas diferencias entre estas dos:

const objetito = {
    name: "Marcus",
    email: "andresmarcorossel@gmail.com",
    age: 29
};

Object.getOwnPropertyNames(objetito);
// ["name", "email", "age"]

-----------------------------------------------------------------
tambien tenemos otros metodos estaticos como Object.entries();
esto nos devolvera un array de arrays.

const objetito = {
    name: "Marcus",
    email: "andresmarcorossel@gmail.com",
    age: 29
};

Object.entries(objetito);
// [
    0: ["name", "Marcus"]
    1: ["email", "andresmarcorossel@gmail.com"]
    2: ["age", 29]
]

-----------------------------------------------------------------
tenemos otro metodo estatico muy importante que es
Object.getOwnPropertyDescriptors(objetito);
nos va a devolver todas las propiedades de nuestro objeto como un objeto pero con el nombre de nuestra propiedad pero despues tenemos otros atributos 

//name: {
    value: "Marcus",
    writable: true,
    configurable: true,
    enumerable: true
}

que significan estas claves, de donde salieron?
son para configurar quien puede axeder, modificar, limitar, jugar nuestros objetos.
esto es muy poderoso.

-->
<!-- 3 métodos estáticos del prototipo object

resumen de los metodos prototipos
------------------------------------------------------------
Object.keys(marco);
    genera en consola los nombres clave en formato lista.

------------------------------------------------------------
Object.getOwnPropertyNames(marco);
    lo mismo que keys pero con lebes diferencias que se veran
    más adelante

------------------------------------------------------------
Object.entries(marco);
    nos permite ver más en profundidad las propiedades de nuestro
    prototipo para chequear los niveles de permiso que traen 
    por defecto.

-->
<!-- 4 Object.defineProperty

al crear las pruebas de Object.defineProperty() jugamos con los valores por defecto para saber que pasa en el navegador y sus diferencias.

Object.defineProperty(marco, "navegator", {
  value: "Chrome",
  enumerable: false,
  writable: true,
  configurable: true
});

cuando enumerable es false, en consola "chrom dev" usamod Object.keys(marco), nos sale el listado de claves pero no aparese navegator.
pero si usamos Object.getOwnPropertyNames(marco), aparecen todos los nombres clave, "esta es la diferencia entre keys y getOwnPropertyNames"

----------------------------------------------------------------------
si aplicamos marco.navigator = "textoDePrueba"
se guarda y por lo tanto se puede seguir ocupando.
tambien podemos eliminarla:     delete marco.navigator
nos mustra un true, por lo que se elimino.

----------------------------------------------------------------------
----------------------------------------------------------------------
Object.defineProperty(marco, "editor", {
  value: "VSCode",
  enumerable: true,
  writable: false,
  configurable: true
});

cuando cambiamos el writable a false pasa lo siguiente.
si aplico Object.keys(marco)  | nos imprime en consola: si aparece en la lista de nombres clave, por que ya tiene el enumerable: true.

si aplicamos marco.editor = "loQueSea", nos dejara pero no lo aplicara
por que con writable: false no nos deja editar.

si aplicamos delete marco.editor | nos sale true, por lo que si se puede eliminar.
------------------------------------------------------------------------------------------------------------------------------------------------
Object.defineProperty(marco, "terminal", {
  value: "WSL",
  enumerable: true,
  writable: true,
  configurable: false
});

si aplicamos configurable: false. 
si usamos Object.keys and Object.getOwnPropertyNames nos sigue mostrando
terminal en la lista de nombres clave.

si aplico marco.terminal = "cmder". si nos deja
pero si aplicamos delete marco.terminal no nos deja.

------------------------------------------------------------------------------------------------------------------------------------------------
Object.defineProperty(marco, "pruebaNASA", {
  value: "extraterrestres",
  enumerable: false,
  writable: false,
  configurable: false
});

con prueba de la nasa no se ve con .keys 
pero con getOwnPropertyNames si nos aparece
no nos deja eliminarla ni editar el valor

-->
<!-- 5 cómo funciona la  memoria en javaScript

si creamos un objeto:

const marco = {
    age: 28,
    email: "andresmarcorossel@gmail.com"
}

luego copiamos estos valores a otro objeto:

const lusho = marco;

si imprimo marco y lusho me daran los mismos datos
pero si modifico lusho en age o email tambien lo aran los de marco.
¿por que pasa esto?.

----------------------------------------------------------------------
----------------------------------------------------------------------
los objetos son referencias a espacios en memoria. por lo que si editamos los elementos de este objeto original tambien modificamos el obejto original. 
entonces. ¿cómo funciona la memoria en javaScript?

javaScript tiene dos memorias | stack   | heap

la memoria stack es muy rapida pero sin mucho espacio
la heap es mucho más lenta y desordenada, 
entonces solo cuando trabajamos con objetos apuntan a estos datos almacenados en heap.
esto no aplica para variables, arrays o funciones.
esto es util por que la memoria heap es muy grande y los objetos suelen tener mucha información.

-->
<!-- 6 shallow copy en javaSript

el shallow copy nos ayuda a arreglar este problema con el apuntador y su valor en la memoria heap.

la solución es la siguiente:

const objeto1 = {
    a: "a",
    b: "b",
};

const objeto2 = {};

for (prop in objeto1) {
    objeto2[prop] = objeto1[prop];
}

ahora podemos modificar los valores del objeto 2 sin dañar los datos originales.
ahora surgue el problema de cuando tenemos objetos o arreglos dentro de este mismo objeto.

const objeto1 = {
    a: "a",
    b: "b",
    c: {d: "d",
        e; "e"}
};

resulta que si modificamos d o e en el original o la copia "objeto2" vuelve a tener problemas de apuntación.

const objeto3 = Object.assign({}, objeto1);

si modificamos objeto1.c.d tambn se modifica el objeto3

const objeto4 = Object.create(objeto1):

esta propiedad nos crea un objeto a partir de otro, como una copia.
si miramos en la consola veremos que los valores estan en prototypo
y se accede a ellos o se modifican sin alterar el original.
pero cuando modifiquemos el original si se alterara esta comipia.

-->
<!-- 7 JSON.parse y JSON.stringify

el shallow copy nos sirve si queremos copiar objetos sin objetos dentro
pero si se complejisa tendremos problemas de apuntación que no podremos soluciónar con shallow copy.

Con JSON.stringify podemos convertir un objeto en un string, pero no es lo mismo. y con JSON.parse podemos convertir un string en un objeto. ¿Confuso no?
nota: Ambos no saben trabajar con funciones

-->
<!-- 8 recursividad 

veamos la estructura basica de la recursividad

function recuersiva() {
    if(/* validación */) {
        //llamados recursivos
    } else {
        // llamados normales, sin recursividad.
    }
}
const numeritos = [0, 1, 3, 6, 7, 4, 2, 0, 7];

let numerito = 0; 

for (let index = 0; index < numeritos.length; index++) {
    console.log({index, numerito})
}

-->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->
<!--  -->