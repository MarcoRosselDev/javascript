<!-- 4 ¿ cuál de los siguientes métodos estáticos de Objet nos perimte listar los atributos "ocultos" en las propiedades de "objetito" ?

bad | Object.entries(objetito)  
repasar la clase 4

Object.defineProperty(objetito) // al parecer nos muestra las propiedades ocultas aparte de las otras propiedades.

Object.defineProperty(objetito, "pruebaNasa", {
    value: "extraterrestre",
    enumerable: true,       //no aparece cuando lo listamos con Object.keys
    writable: true,         //false no deja asignarle otro valor a value
    configurable: true,     //false no deja eliniminar
}) ;


-->
<!-- 5 ¿ cuál de los siguientes métodos estáticos de Object nos permite definir o editar los atributos "ocultos" en la propiedad "patito" de "objetito" ?

bad | Object.getOwnPropertyDescriptors(objetito)
puede ser | Object.defineProperty(objetito.prototype, "patito", {});
repasar la clase 17

1-queremos protejer la propiedad learningPaths que esta así:

if (isArray(learnungPhats)) {
    this.learningPaths = [];
}

resulta que si en consola le decirmos juan.learningPaths = "lalala";
se le asignara ese texto y no tendremos los learning paths. "rutas de aprendizaje"

2-lo primero es decirle a this.learningPaths que sea _learningPaths, que por convencion es un atributo privado

-->
<!-- 11 ¿ cómo creamos getters y setters en prototipo ?

bad | Retornando un objeto con get nombrePropiedad() { /* ... */} y set nombrePropiedad
repasar clase 17

get nombrePropiedad() {/* ... */}y
set nombrePropiedad(newNombrePropiedad) {
    if() {

    } else {

    }
}

-->
<!-- 13 ¿ qué es una fábrica de objetos ?

bad | lo mismo que un prototipo, pero con la sintaxis de clases
repasar clase 11

lo mismo que prototipo, pero con funciónes.
recive objetos y retorna otro objeto.
repasar la clase 16

-->
<!-- 16 ¿ Cómo identificamos objetos con Duck Typing en JavaScript? ?

bad | creando un método especial de validación que no se pueda replicar en objetos impostores.
repasar clase 15

creando una fución con roro

function crearRutas ({
    name = requeriedParam("name"),
    courses = [],
}) {
    const private = {};

    const public = {};

    return public;
}

-->
<!-- 18 ¿ cuál es el problema de crear copias de objetos con JSON.parse y JSON.stringify ?

bad | Que copian las referencias en memoria del objeto original, no las propiedades del objeto como tal.

repasar clase 7

.stringify = creamos un string a partir de un objeto
.parse = creamos un objeto a partir de un string

cual es el problema?, funciona bien, pero si trabajamos con funciones, metodos no los reconosen.

-->
<!--  -->